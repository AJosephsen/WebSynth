<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSynth - Software Synthesis Explorer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --rack-bg: #1b1b1b;
            --panel-bg: #2d2d2d;
            --accent-primary: #f2c744;
            --accent-secondary: #f8633b;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at top, #2f2f2f 0%, #080808 60%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #f4f4f4;
        }

        .container {
            background: linear-gradient(145deg, #2b2b2b, #1c1c1c);
            border-radius: 22px;
            padding: 40px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7), 0 25px 60px rgba(0, 0, 0, 0.8);
            max-width: 1100px;
            width: 100%;
            border: 4px solid #050505;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            color: #f7dd9b;
            margin-bottom: 10px;
            text-align: center;
            letter-spacing: 4px;
        }

        .subtitle {
            text-align: center;
            color: #c6c6c6;
            margin-bottom: 30px;
            font-size: 13px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .top-panel {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(120deg, #3a3a3a, #1b1b1b);
            padding: 20px 25px;
            border-radius: 14px;
            border: 2px solid #0f0f0f;
            box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.6);
        }

        .power-module {
            display: flex;
            align-items: center;
            gap: 20px;
            background: #1a1a1a;
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #070707;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.6);
        }

        .power-label {
            display: flex;
            flex-direction: column;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #f7dd9b;
        }

        .status-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-top: 6px;
            background: #3c3c3c;
            box-shadow: inset 0 0 4px #000;
            transition: background 0.3s, box-shadow 0.3s;
        }

        .status-dot.on {
            background: #4eff5a;
            box-shadow: 0 0 12px #62ff6c;
        }

        .power-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }

        .power-switch input {
            appearance: none;
            width: 0;
            height: 0;
            position: absolute;
        }

        .switch-body {
            width: 90px;
            height: 36px;
            border-radius: 18px;
            background: linear-gradient(145deg, #3c3c3c, #1f1f1f);
            border: 2px solid #070707;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            position: relative;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.6);
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 1px;
        }

        .switch-label {
            flex: 1;
            text-align: center;
            color: #777;
            z-index: 1;
        }

        .switch-label.off {
            color: #777;
        }

        .power-switch input:not(:checked) + .switch-body .switch-label.off {
            color: #f25d4d;
        }

        .power-switch input:checked + .switch-body .switch-label.on {
            color: var(--accent-primary);
        }

        .power-switch input:checked + .switch-body .switch-label.off {
            color: #555;
        }

        .power-switch input:not(:checked) + .switch-body .switch-label.on {
            color: #555;
        }

        .switch-toggle {
            position: absolute;
            top: 4px;
            left: 6px;
            width: 36px;
            height: 28px;
            border-radius: 14px;
            background: linear-gradient(145deg, #f7dd9b, #d3a749);
            box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s ease;
        }

        .power-switch input:checked + .switch-body .switch-toggle {
            transform: translateX(44px);
        }

        .octave-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #1a1a1a;
            padding: 12px 18px;
            border-radius: 12px;
            border: 2px solid #070707;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.6);
        }

        .octave-btn {
            background: linear-gradient(145deg, var(--accent-secondary), #c94426);
            color: #1b0101;
            padding: 10px 20px;
            font-size: 13px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease;
        }

        .octave-btn:hover {
            transform: translateY(-1px);
        }

        #octaveDisplay {
            font-size: 16px;
            font-weight: 600;
            color: #f7dd9b;
            min-width: 110px;
            text-align: center;
            letter-spacing: 2px;
        }

        .keyboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .key {
            background: linear-gradient(180deg, #f8f8f6 0%, #d8d8d6 70%, #b5b5b3 100%);
            border: 3px solid #111;
            border-radius: 6px;
            padding: 20px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.1s ease;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            touch-action: none;
            box-shadow: 0 6px 0 #050505, inset 0 0 8px rgba(0, 0, 0, 0.15);
            color: #1b1b1b;
        }

        .key:hover {
            transform: translateY(1px);
        }

        .key.active {
            background: linear-gradient(180deg, #f2c744 0%, #f59f35 100%);
            color: #1b1b1b;
            transform: translateY(3px);
            box-shadow: 0 3px 0 #050505;
        }

        .key-label {
            font-size: 18px;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        .key-note {
            font-size: 12px;
            color: #666;
        }

        .key.active .key-note {
            color: #fff;
        }

        .synth-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: var(--panel-bg);
            border-radius: 12px;
            padding: 20px;
            color: #f5f5f5;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #070707;
            display: flex;
            flex-direction: column;
        }

        .control-panel h3 {
            margin-bottom: 15px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-primary);
            border-bottom: 2px solid var(--accent-primary);
            padding-bottom: 8px;
        }

        .control-panel h4 {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #f1c769;
            margin-bottom: 12px;
        }

        .sub-panel {
            margin-top: 18px;
            padding-top: 18px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
            color: #d4d4d4;
            letter-spacing: 1px;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 2px solid #161616;
            background: #0e0e0e;
            color: #fdfdfd;
            font-size: 14px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .control-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #0e0e0e;
            outline: none;
            border: 2px solid #161616;
            appearance: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(145deg, var(--accent-primary), #f39c1a);
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 223, 128, 0.6);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(145deg, var(--accent-primary), #f39c1a);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(255, 223, 128, 0.6);
        }

        .slider-value {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
            color: var(--accent-primary);
        }

        .info {
            margin-top: 30px;
            padding: 20px;
            background: #121212;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #050505;
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.5);
        }

        .info h3 {
            color: #f7dd9b;
            margin-bottom: 10px;
        }

        .info p {
            color: #c4c4c4;
            line-height: 1.6;
        }

        .status {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .status.active {
            background: rgba(78, 255, 90, 0.15);
            color: #4eff5a;
            border: 1px solid #4eff5a;
        }

        .status.inactive {
            background: rgba(255, 51, 51, 0.12);
            color: #ff5e5e;
            border: 1px solid #ff5e5e;
        }

        .wave-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .wave-btn {
            padding: 8px;
            background: #0f0f0f;
            border: 2px solid #050505;
            border-radius: 6px;
            color: #bbb;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 11px;
            text-transform: uppercase;
        }

        .wave-btn.active {
            background: var(--accent-primary);
            border-color: #c98616;
            color: #1b1b1b;
        }

        .wave-btn:hover {
            border-color: var(--accent-primary);
        }

        @media (min-width: 1100px) {
            .synth-controls {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéπ WebSynth</h1>
        <p class="subtitle">Real-Time Software Synthesis with Filters & Reverb</p>

        <div class="top-panel">
            <div class="power-module">
                <div class="power-label">
                    <span>Power</span>
                    <span class="status-dot" id="powerLamp"></span>
                </div>
                <label class="power-switch">
                    <input type="checkbox" id="powerToggle">
                    <span class="switch-body">
                        <span class="switch-label off">Off</span>
                        <span class="switch-label on">On</span>
                        <span class="switch-toggle"></span>
                    </span>
                </label>
            </div>

            <div class="octave-controls">
                <button class="octave-btn" id="octaveDown">Octave -</button>
                <span id="octaveDisplay">Octave: 4</span>
                <button class="octave-btn" id="octaveUp">Octave +</button>
            </div>
        </div>

        <div class="status inactive" id="status">Power Rail: Standby</div>

        <div class="synth-controls">
            <div class="control-panel">
                <h3>üéõÔ∏è Oscillator</h3>
                <div class="control-group">
                    <label>Waveform</label>
                    <div class="wave-selector">
                        <div class="wave-btn active" data-wave="sine">Sine</div>
                        <div class="wave-btn" data-wave="square">Square</div>
                        <div class="wave-btn" data-wave="sawtooth">Saw</div>
                        <div class="wave-btn" data-wave="triangle">Tri</div>
                    </div>
                </div>

                <div class="sub-panel">
                    <h4>Oscillator 2</h4>
                    <div class="control-group">
                        <label>Waveform</label>
                        <select id="osc2Waveform">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="sawtooth" selected>Sawtooth</option>
                            <option value="triangle">Triangle</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Detune</label>
                        <input type="range" id="osc2Detune" min="-100" max="100" value="0" step="1">
                        <div class="slider-value">
                            <span>-1200¬¢</span>
                            <span id="osc2DetuneValue">0¬¢</span>
                            <span>+1200¬¢</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Level</label>
                        <input type="range" id="osc2Level" min="0" max="1" step="0.01" value="0.5">
                        <div class="slider-value">
                            <span>Mute</span>
                            <span id="osc2LevelValue">50%</span>
                            <span>Full</span>
                        </div>
                    </div>
                </div>

                <div class="sub-panel">
                    <h4>Amplitude Envelope</h4>
                    <div class="control-group">
                        <label>Attack</label>
                        <input type="range" id="envAttack" min="0" max="2" step="0.01" value="0.03">
                        <div class="slider-value">
                            <span>0s</span>
                            <span id="envAttackValue">0.03s</span>
                            <span>2s</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Decay</label>
                        <input type="range" id="envDecay" min="0" max="2" step="0.01" value="0.2">
                        <div class="slider-value">
                            <span>0s</span>
                            <span id="envDecayValue">0.20s</span>
                            <span>2s</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Sustain</label>
                        <input type="range" id="envSustain" min="0" max="100" step="1" value="70">
                        <div class="slider-value">
                            <span>0%</span>
                            <span id="envSustainValue">70%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Release</label>
                        <input type="range" id="envRelease" min="0" max="4" step="0.01" value="0.4">
                        <div class="slider-value">
                            <span>0s</span>
                            <span id="envReleaseValue">0.40s</span>
                            <span>4s</span>
                        </div>
                    </div>
                </div>

                <div class="sub-panel">
                    <h4>Transient Sculptor</h4>
                    <div class="control-group">
                        <label>Attack Boost</label>
                        <input type="range" id="transientAmount" min="0" max="12" step="0.1" value="6">
                        <div class="slider-value">
                            <span>0 dB</span>
                            <span id="transientAmountValue">+6.0 dB</span>
                            <span>+12 dB</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Length</label>
                        <input type="range" id="transientLength" min="5" max="120" step="1" value="40">
                        <div class="slider-value">
                            <span>5ms</span>
                            <span id="transientLengthValue">40ms</span>
                            <span>120ms</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h3>üåê LFO</h3>
                <div class="control-group">
                    <label>Target</label>
                    <select id="lfoTarget">
                        <option value="off" selected>Off</option>
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Waveform</label>
                    <select id="lfoWaveform">
                        <option value="sine" selected>Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Saw</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Rate</label>
                    <input type="range" id="lfoRate" min="0.1" max="15" value="4" step="0.1">
                    <div class="slider-value">
                        <span>0.1Hz</span>
                        <span id="lfoRateValue">4.0Hz</span>
                        <span>15Hz</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Depth</label>
                    <input type="range" id="lfoDepth" min="0" max="100" value="25" step="1">
                    <div class="slider-value">
                        <span>Subtle</span>
                        <span id="lfoDepthValue">25</span>
                        <span>Wide</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h3>üî• Drive & Fold</h3>
                <div class="control-group">
                    <label>Drive</label>
                    <input type="range" id="driveAmount" min="0" max="24" step="0.5" value="8">
                    <div class="slider-value">
                        <span>Clean</span>
                        <span id="driveAmountValue">+8.0 dB</span>
                        <span>Hot</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Fold Depth</label>
                    <input type="range" id="foldAmount" min="0" max="100" step="1" value="20">
                    <div class="slider-value">
                        <span>Soft</span>
                        <span id="foldAmountValue">20%</span>
                        <span>Folded</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Tone Tilt</label>
                    <input type="range" id="toneTilt" min="-12" max="12" step="0.5" value="0">
                    <div class="slider-value">
                        <span>Darker</span>
                        <span id="toneTiltValue">0 dB</span>
                        <span>Brighter</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h3>üîä Filter</h3>
                <div class="control-group">
                    <label>Filter Type</label>
                    <select id="filterType">
                        <option value="lowpass">Low Pass</option>
                        <option value="highpass">High Pass</option>
                        <option value="bandpass">Band Pass</option>
                        <option value="notch">Notch</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Cutoff Frequency</label>
                    <input type="range" id="filterCutoff" min="20" max="20000" value="2000" step="1">
                    <div class="slider-value">
                        <span>20Hz</span>
                        <span id="cutoffValue">2000Hz</span>
                        <span>20kHz</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Resonance (Q)</label>
                    <input type="range" id="filterResonance" min="0.1" max="30" value="1" step="0.1">
                    <div class="slider-value">
                        <span>0.1</span>
                        <span id="resonanceValue">1.0</span>
                        <span>30</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h3>üåä Reverb</h3>
                <div class="control-group">
                    <label>Room Size</label>
                    <input type="range" id="reverbRoomSize" min="0.1" max="5" value="1.5" step="0.1">
                    <div class="slider-value">
                        <span>Small</span>
                        <span id="roomSizeValue">1.5s</span>
                        <span>Large</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Decay Time</label>
                    <input type="range" id="reverbDecay" min="0.1" max="10" value="2" step="0.1">
                    <div class="slider-value">
                        <span>0.1s</span>
                        <span id="decayValue">2.0s</span>
                        <span>10s</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Wet/Dry Mix</label>
                    <input type="range" id="reverbMix" min="0" max="100" value="30" step="1">
                    <div class="slider-value">
                        <span>Dry</span>
                        <span id="mixValue">30%</span>
                        <span>Wet</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="keyboard" id="keyboard"></div>

        <div class="info">
            <h3>How to Play</h3>
            <p>
                Flip the illuminated <strong>power switch</strong> to boot the synth.
                Use keyboard keys <strong>A, S, D, F, G, H, J, K</strong> to play notes.
                Change octaves with the module buttons or tap <strong>Z</strong> (down) / <strong>X</strong> (up).
                Layer Oscillator 2 detune and route the LFO for classic vibrato or filter sweeps.
                If your browser supports the Web MIDI API, connect a hardware controller and play with full velocity sensitivity.
            </p>
        </div>
    </div>

    <script>
        let audioContext = null;
        let activeOscillators = {};
        let currentOctave = 4;
        let masterGain = null;
        let reverbNode = null;
        let dryGain = null;
        let wetGain = null;
        let midiAccess = null;
        const midiInputHandlers = new Map();
        const activeTouchMap = new Map();

        let synthParams = {
            waveform: 'sine',
            filterType: 'lowpass',
            filterCutoff: 2000,
            filterResonance: 1,
            reverbRoomSize: 1.5,
            reverbDecay: 2,
            reverbMix: 30,
            osc2Waveform: 'sawtooth',
            osc2Detune: 0,
            osc2Level: 0.5,
            lfoTarget: 'off',
            lfoWaveform: 'sine',
            lfoRate: 4,
            lfoDepth: 25,
            envAttack: 0.03,
            envDecay: 0.2,
            envSustain: 0.7,
            envRelease: 0.4,
            transientAmount: 6,
            transientLength: 0.04,
            driveAmount: 8,
            foldAmount: 20,
            toneTilt: 0
        };

        const noteFrequencies = {
            'C': 261.63,
            'D': 293.66,
            'E': 329.63,
            'F': 349.23,
            'G': 392.00,
            'A': 440.00,
            'B': 493.88,
            'C2': 523.25
        };

        const keyMap = {
            'a': 'C',
            's': 'D',
            'd': 'E',
            'f': 'F',
            'g': 'G',
            'h': 'A',
            'j': 'B',
            'k': 'C2'
        };

        const DETUNE_MAX_CENTS = 1200;
        const DETUNE_CURVE_POWER = 1.7;
        const VOICE_MAX_GAIN = 0.32;
        let driveCurve = null;

        function formatDetune(value) {
            const rounded = Math.round(value);
            return `${rounded > 0 ? '+' : ''}${rounded}¬¢`;
        }

        function detuneSliderToCents(value) {
            const normalized = value / 100; // -1..1
            const curved = Math.sign(normalized) * Math.pow(Math.abs(normalized), DETUNE_CURVE_POWER);
            return curved * DETUNE_MAX_CENTS;
        }

        function centsToDetuneSlider(cents) {
            const clamped = Math.max(-DETUNE_MAX_CENTS, Math.min(DETUNE_MAX_CENTS, cents));
            const normalized = Math.sign(clamped) * Math.pow(Math.abs(clamped) / DETUNE_MAX_CENTS, 1 / DETUNE_CURVE_POWER);
            return normalized * 100;
        }

        function dbToLinear(db) {
            return Math.pow(10, db / 20);
        }

        function buildDriveCurve(driveDb, foldPercent) {
            const samples = 1024;
            const curve = new Float32Array(samples);
            const foldMix = Math.max(0, Math.min(1, foldPercent));
            const driveGain = dbToLinear(driveDb);
            for (let i = 0; i < samples; i++) {
                const x = (i / (samples - 1)) * 2 - 1;
                const driven = Math.tanh(x * driveGain * 2);
                const folded = Math.sin(driven * (1 + foldMix * 4));
                curve[i] = (1 - foldMix) * driven + foldMix * folded;
            }
            return curve;
        }

        function ensureDriveCurve() {
            if (!driveCurve) {
                driveCurve = buildDriveCurve(synthParams.driveAmount, synthParams.foldAmount / 100);
            }
            return driveCurve;
        }

        function applyDriveSettingsToVoice(voice, linearGain, tiltGain, time) {
            if (!voice) {
                return;
            }
            if (voice.drivePreGain) {
                voice.drivePreGain.gain.setValueAtTime(linearGain, time);
            }
            if (voice.driveWaveShaper) {
                voice.driveWaveShaper.curve = ensureDriveCurve();
            }
            if (voice.toneFilter) {
                voice.toneFilter.gain.setValueAtTime(tiltGain, time);
            }
        }

        function updateDriveModuleSettings() {
            driveCurve = buildDriveCurve(synthParams.driveAmount, synthParams.foldAmount / 100);
            if (!audioContext) {
                return;
            }
            const linearGain = dbToLinear(synthParams.driveAmount);
            const tiltGain = synthParams.toneTilt;
            const time = audioContext.currentTime;
            Object.values(activeOscillators).forEach(voice => applyDriveSettingsToVoice(voice, linearGain, tiltGain, time));
        }

        function applyTransientEnvelope(node, startTime) {
            if (!node) {
                return;
            }
            node.gain.cancelScheduledValues(startTime);
            node.gain.setValueAtTime(1, startTime);
            if (synthParams.transientAmount <= 0.001) {
                return;
            }
            const boost = dbToLinear(synthParams.transientAmount);
            const length = Math.max(0.005, synthParams.transientLength);
            node.gain.setValueAtTime(boost, startTime);
            node.gain.linearRampToValueAtTime(1, startTime + length);
        }

        function midiNoteToFrequency(noteNumber) {
            return 440 * Math.pow(2, (noteNumber - 69) / 12);
        }

        function init() {
            createKeyboard();
            setupEventListeners();
            setupSynthControls();
            setupMIDI();
        }

        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            Object.entries(keyMap).forEach(([key, note]) => {
                const keyElement = document.createElement('div');
                keyElement.className = 'key';
                keyElement.dataset.key = key;
                keyElement.dataset.note = note;
                keyElement.innerHTML = `
                    <span class="key-label">${key.toUpperCase()}</span>
                    <span class="key-note">${note}</span>
                `;
                
                keyElement.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    playNote(note, key);
                });
                keyElement.addEventListener('mouseup', (event) => {
                    event.preventDefault();
                    stopNote(key);
                });
                keyElement.addEventListener('mouseleave', () => stopNote(key));

                keyElement.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    Array.from(event.changedTouches).forEach(touch => {
                        const touchKey = `${key}-touch-${touch.identifier}`;
                        if (activeTouchMap.has(touch.identifier)) {
                            return;
                        }
                        activeTouchMap.set(touch.identifier, touchKey);
                        playNote(note, touchKey, { uiKey: key });
                    });
                });

                const endTouch = (event) => {
                    event.preventDefault();
                    Array.from(event.changedTouches).forEach(touch => {
                        const touchKey = activeTouchMap.get(touch.identifier);
                        if (touchKey) {
                            stopNote(touchKey);
                            activeTouchMap.delete(touch.identifier);
                        }
                    });
                };

                keyElement.addEventListener('touchend', endTouch);
                keyElement.addEventListener('touchcancel', endTouch);
                
                keyboard.appendChild(keyElement);
            });
        }

        function setupEventListeners() {
            const powerToggle = document.getElementById('powerToggle');
            powerToggle.addEventListener('change', async (e) => {
                if (e.target.checked) {
                    await startAudio();
                } else {
                    stopAudio();
                }
            });
            document.getElementById('octaveUp').addEventListener('click', () => changeOctave(1));
            document.getElementById('octaveDown').addEventListener('click', () => changeOctave(-1));
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        async function setupMIDI() {
            if (!navigator.requestMIDIAccess) {
                console.warn('Web MIDI API is not supported in this browser.');
                return;
            }

            try {
                midiAccess = await navigator.requestMIDIAccess();
                midiAccess.inputs.forEach(input => attachMIDIInput(input));
                midiAccess.addEventListener('statechange', handleMIDIStateChange);
            } catch (error) {
                console.warn('Failed to initialize MIDI:', error);
            }
        }

        function handleMIDIStateChange(event) {
            const port = event.port;
            if (!port || port.type !== 'input') {
                return;
            }

            if (port.state === 'connected') {
                attachMIDIInput(port);
            } else if (port.state === 'disconnected') {
                detachMIDIInput(port);
            }
        }

        function attachMIDIInput(input) {
            if (!input || midiInputHandlers.has(input.id)) {
                return;
            }

            const handler = (event) => handleMIDIMessage(event);
            input.addEventListener('midimessage', handler);
            midiInputHandlers.set(input.id, handler);

            if (typeof input.open === 'function') {
                input.open().catch(() => {
                    /* no-op */
                });
            }

            console.log(`MIDI input connected: ${input.name}`);
        }

        function detachMIDIInput(input) {
            const handler = midiInputHandlers.get(input.id);
            if (handler) {
                input.removeEventListener('midimessage', handler);
                midiInputHandlers.delete(input.id);
            }
        }

        async function handleMIDIMessage(event) {
            const [status, data1, data2] = event.data;
            const command = status & 0xf0;
            const channel = status & 0x0f;
            const noteNumber = data1;
            const keyId = `midi-${channel}-${noteNumber}`;

            if (command === 0x90 && data2 > 0) {
                const frequency = midiNoteToFrequency(noteNumber);
                const velocity = data2 / 127;
                if (activeOscillators[keyId]) {
                    stopNote(keyId);
                }
                await playNote('MIDI', keyId, {
                    frequencyOverride: frequency,
                    bypassOctave: true,
                    velocity
                });
            } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
                stopNote(keyId);
            }
        }

        function createReverb() {
            const convolver = audioContext.createConvolver();
            const reverbTime = synthParams.reverbRoomSize * synthParams.reverbDecay;
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * reverbTime;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 2);
                    channelData[i] = (Math.random() * 2 - 1) * decay;
                }
            }
            
            convolver.buffer = impulse;
            return convolver;
        }

        async function startAudio() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    masterGain = audioContext.createGain();
                    masterGain.gain.setValueAtTime(0.7, audioContext.currentTime);
                    
                    dryGain = audioContext.createGain();
                    wetGain = audioContext.createGain();
                    
                    updateReverbMix();
                    
                    reverbNode = createReverb();
                    
                    masterGain.connect(dryGain);
                    masterGain.connect(reverbNode);
                    reverbNode.connect(wetGain);
                    
                    dryGain.connect(audioContext.destination);
                    wetGain.connect(audioContext.destination);
                }
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                updateStatus(true);
            } catch (error) {
                console.error('Error starting audio:', error);
                alert('Failed to start audio. Please try again.');
            }
        }

        function stopAudio() {
            if (audioContext) {
                Object.keys(activeOscillators).forEach(key => stopNote(key));
                activeTouchMap.clear();
                audioContext.suspend();
                updateStatus(false);
            }
        }

        function updatePowerUI(active) {
            const toggle = document.getElementById('powerToggle');
            const lamp = document.getElementById('powerLamp');
            if (toggle) {
                toggle.checked = active;
            }
            if (lamp) {
                lamp.classList.toggle('on', active);
            }
        }

        function updateStatus(active) {
            const status = document.getElementById('status');
            if (active) {
                status.className = 'status active';
                status.textContent = 'Power Rail: Online';
            } else {
                status.className = 'status inactive';
                status.textContent = 'Power Rail: Standby';
            }
            updatePowerUI(active);
        }

        function updateReverbMix() {
            if (dryGain && wetGain) {
                const wetAmount = synthParams.reverbMix / 100;
                const dryAmount = 1 - wetAmount;
                dryGain.gain.setValueAtTime(dryAmount, audioContext.currentTime);
                wetGain.gain.setValueAtTime(wetAmount, audioContext.currentTime);
            }
        }

        function updateReverb() {
            if (audioContext && reverbNode) {
                reverbNode.disconnect();
                reverbNode = createReverb();
                masterGain.connect(reverbNode);
                reverbNode.connect(wetGain);
            }
        }

        function createVoiceLFO(voice) {
            if (!audioContext || !voice) {
                return null;
            }
            if (synthParams.lfoTarget === 'off' || synthParams.lfoDepth <= 0) {
                return null;
            }

            const lfoOsc = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();

            lfoOsc.type = synthParams.lfoWaveform;
            lfoOsc.frequency.setValueAtTime(synthParams.lfoRate, audioContext.currentTime);

            if (synthParams.lfoTarget === 'pitch') {
                lfoGain.gain.setValueAtTime(synthParams.lfoDepth, audioContext.currentTime);
                lfoOsc.connect(lfoGain);
                if (voice.osc1) {
                    lfoGain.connect(voice.osc1.detune);
                }
                if (voice.osc2) {
                    lfoGain.connect(voice.osc2.detune);
                }
            } else if (synthParams.lfoTarget === 'filter' && voice.filter) {
                lfoGain.gain.setValueAtTime(synthParams.lfoDepth * 20, audioContext.currentTime);
                lfoOsc.connect(lfoGain);
                lfoGain.connect(voice.filter.frequency);
            } else {
                lfoOsc.disconnect();
                lfoGain.disconnect();
                return null;
            }

            lfoOsc.start();
            return { lfoOsc, lfoGain };
        }

        function teardownVoiceLFO(voice) {
            if (voice.lfoOsc) {
                try {
                    voice.lfoOsc.stop();
                } catch (error) {
                    /* no-op */
                }
                voice.lfoOsc.disconnect();
                delete voice.lfoOsc;
            }
            if (voice.lfoGain) {
                voice.lfoGain.disconnect();
                delete voice.lfoGain;
            }
        }

        function rebuildVoiceLFO(voice) {
            teardownVoiceLFO(voice);
            const lfoNodes = createVoiceLFO(voice);
            if (lfoNodes) {
                voice.lfoOsc = lfoNodes.lfoOsc;
                voice.lfoGain = lfoNodes.lfoGain;
            }
        }

        function rebuildAllVoiceLFOs() {
            Object.values(activeOscillators).forEach(voice => rebuildVoiceLFO(voice));
        }

        async function playNote(note, key, options = {}) {
            const {
                frequencyOverride = null,
                bypassOctave = false,
                velocity = 1,
                uiKey = key
            } = options;
            if (!audioContext || audioContext.state !== 'running') {
                await startAudio();
            }
            
            if (!audioContext || audioContext.state !== 'running' || !masterGain) {
                console.warn('Audio context not ready');
                return;
            }

            if (activeOscillators[key]) {
                return;
            }

            const baseFreq = frequencyOverride ?? noteFrequencies[note];
            if (!baseFreq) {
                console.warn('Unknown note frequency for', note);
                return;
            }

            const octaveMultiplier = bypassOctave ? 1 : Math.pow(2, currentOctave - 4);
            const frequency = baseFreq * octaveMultiplier;
            const normalizedVelocity = Math.max(0, Math.min(1, velocity));
            const peakGain = VOICE_MAX_GAIN * (normalizedVelocity > 0 ? normalizedVelocity : 1);

            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const osc2Gain = audioContext.createGain();
            const transientGain = audioContext.createGain();
            const drivePreGain = audioContext.createGain();
            const driveWaveShaper = audioContext.createWaveShaper();
            const toneFilter = audioContext.createBiquadFilter();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            const now = audioContext.currentTime;

            osc1.type = synthParams.waveform;
            osc1.frequency.setValueAtTime(frequency, now);

            osc2.type = synthParams.osc2Waveform;
            osc2.frequency.setValueAtTime(frequency, now);
            osc2.detune.setValueAtTime(synthParams.osc2Detune, now);
            osc2Gain.gain.setValueAtTime(synthParams.osc2Level, now);

            transientGain.gain.setValueAtTime(1, now);
            applyTransientEnvelope(transientGain, now);

            driveWaveShaper.oversample = '4x';
            driveWaveShaper.curve = ensureDriveCurve();

            const driveLinearGain = dbToLinear(synthParams.driveAmount);
            drivePreGain.gain.setValueAtTime(driveLinearGain, now);

            toneFilter.type = 'highshelf';
            toneFilter.frequency.setValueAtTime(1800, now);
            toneFilter.gain.setValueAtTime(synthParams.toneTilt, now);

            filter.type = synthParams.filterType;
            filter.frequency.setValueAtTime(synthParams.filterCutoff, now);
            filter.Q.setValueAtTime(synthParams.filterResonance, now);

            const attackTime = Math.max(0.001, synthParams.envAttack);
            const decayTime = Math.max(0.001, synthParams.envDecay);
            const sustainLevel = Math.max(0, Math.min(1, synthParams.envSustain));

            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(peakGain, now + attackTime);
            gainNode.gain.linearRampToValueAtTime(
                peakGain * sustainLevel,
                now + attackTime + decayTime
            );

            osc1.connect(transientGain);
            osc2.connect(osc2Gain);
            osc2Gain.connect(transientGain);
            transientGain.connect(drivePreGain);
            drivePreGain.connect(driveWaveShaper);
            driveWaveShaper.connect(toneFilter);
            toneFilter.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(masterGain);

            osc1.start();
            osc2.start();

            const voice = { osc1, osc2, osc2Gain, transientGain, drivePreGain, driveWaveShaper, toneFilter, gainNode, filter, uiKey };
            applyDriveSettingsToVoice(voice, driveLinearGain, synthParams.toneTilt, now);
            activeOscillators[key] = voice;
            rebuildVoiceLFO(voice);

            const keyElement = document.querySelector(`[data-key="${uiKey}"]`);
            if (keyElement) {
                keyElement.classList.add('active');
            }
        }

        function stopNote(key) {
            const voice = activeOscillators[key];
            if (voice) {
                const { gainNode, osc1, osc2 } = voice;
                const now = audioContext.currentTime;
                const releaseTime = Math.max(0.01, synthParams.envRelease);
                const stopTime = now + releaseTime + 0.05;

                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                [osc1, osc2].forEach(osc => {
                    if (osc) {
                        try {
                            osc.stop(stopTime);
                        } catch (error) {
                            /* no-op */
                        }
                    }
                });

                teardownVoiceLFO(voice);
                delete activeOscillators[key];

                const keyElement = document.querySelector(`[data-key="${voice.uiKey || key}"]`);
                if (keyElement) {
                    keyElement.classList.remove('active');
                }
            }
        }

        function setupSynthControls() {
            const osc2DetuneSlider = document.getElementById('osc2Detune');
            const osc2DetuneValue = document.getElementById('osc2DetuneValue');
            const osc2LevelValue = document.getElementById('osc2LevelValue');
            const lfoRateValue = document.getElementById('lfoRateValue');
            const lfoDepthValue = document.getElementById('lfoDepthValue');
            const envAttackValue = document.getElementById('envAttackValue');
            const envDecayValue = document.getElementById('envDecayValue');
            const envSustainValue = document.getElementById('envSustainValue');
            const envReleaseValue = document.getElementById('envReleaseValue');
            const transientAmountValue = document.getElementById('transientAmountValue');
            const transientLengthValue = document.getElementById('transientLengthValue');
            const driveAmountValue = document.getElementById('driveAmountValue');
            const foldAmountValue = document.getElementById('foldAmountValue');
            const toneTiltValue = document.getElementById('toneTiltValue');

            if (osc2DetuneSlider && osc2DetuneValue) {
                osc2DetuneSlider.value = centsToDetuneSlider(synthParams.osc2Detune);
                osc2DetuneValue.textContent = formatDetune(synthParams.osc2Detune);
            }
            if (osc2LevelValue) {
                osc2LevelValue.textContent = Math.round(synthParams.osc2Level * 100) + '%';
            }
            if (lfoRateValue) {
                lfoRateValue.textContent = synthParams.lfoRate.toFixed(1) + 'Hz';
            }
            if (lfoDepthValue) {
                lfoDepthValue.textContent = synthParams.lfoDepth.toFixed(0);
            }
            if (envAttackValue) {
                envAttackValue.textContent = synthParams.envAttack.toFixed(2) + 's';
            }
            if (envDecayValue) {
                envDecayValue.textContent = synthParams.envDecay.toFixed(2) + 's';
            }
            if (envSustainValue) {
                envSustainValue.textContent = Math.round(synthParams.envSustain * 100) + '%';
            }
            if (envReleaseValue) {
                envReleaseValue.textContent = synthParams.envRelease.toFixed(2) + 's';
            }
            if (transientAmountValue) {
                transientAmountValue.textContent = `+${synthParams.transientAmount.toFixed(1)} dB`;
            }
            if (transientLengthValue) {
                transientLengthValue.textContent = Math.round(synthParams.transientLength * 1000) + 'ms';
            }
            if (driveAmountValue) {
                driveAmountValue.textContent = `+${synthParams.driveAmount.toFixed(1)} dB`;
            }
            if (foldAmountValue) {
                foldAmountValue.textContent = Math.round(synthParams.foldAmount) + '%';
            }
            if (toneTiltValue) {
                toneTiltValue.textContent = synthParams.toneTilt.toFixed(1) + ' dB';
            }

            const envAttackSlider = document.getElementById('envAttack');
            if (envAttackSlider) {
                envAttackSlider.value = synthParams.envAttack;
            }
            const envDecaySlider = document.getElementById('envDecay');
            if (envDecaySlider) {
                envDecaySlider.value = synthParams.envDecay;
            }
            const envSustainSlider = document.getElementById('envSustain');
            if (envSustainSlider) {
                envSustainSlider.value = Math.round(synthParams.envSustain * 100);
            }
            const envReleaseSlider = document.getElementById('envRelease');
            if (envReleaseSlider) {
                envReleaseSlider.value = synthParams.envRelease;
            }
            const transientAmountSlider = document.getElementById('transientAmount');
            if (transientAmountSlider) {
                transientAmountSlider.value = synthParams.transientAmount;
            }
            const transientLengthSlider = document.getElementById('transientLength');
            if (transientLengthSlider) {
                transientLengthSlider.value = Math.round(synthParams.transientLength * 1000);
            }
            const driveAmountSlider = document.getElementById('driveAmount');
            if (driveAmountSlider) {
                driveAmountSlider.value = synthParams.driveAmount;
            }
            const foldAmountSlider = document.getElementById('foldAmount');
            if (foldAmountSlider) {
                foldAmountSlider.value = synthParams.foldAmount;
            }
            const toneTiltSlider = document.getElementById('toneTilt');
            if (toneTiltSlider) {
                toneTiltSlider.value = synthParams.toneTilt;
            }

            document.querySelectorAll('.wave-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.wave-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    synthParams.waveform = btn.dataset.wave;
                    
                    Object.values(activeOscillators).forEach(voice => {
                        if (voice.osc1 && voice.osc1.type !== synthParams.waveform) {
                            voice.osc1.type = synthParams.waveform;
                        }
                    });
                });
            });

            document.getElementById('osc2Waveform').addEventListener('change', (e) => {
                synthParams.osc2Waveform = e.target.value;
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.osc2) {
                        voice.osc2.type = synthParams.osc2Waveform;
                    }
                });
            });

            document.getElementById('osc2Detune').addEventListener('input', (e) => {
                const sliderPosition = parseFloat(e.target.value);
                const cents = detuneSliderToCents(sliderPosition);
                synthParams.osc2Detune = cents;
                if (osc2DetuneValue) {
                    osc2DetuneValue.textContent = formatDetune(cents);
                }
                if (!audioContext) {
                    return;
                }
                const time = audioContext.currentTime;
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.osc2) {
                        voice.osc2.detune.setValueAtTime(cents, time);
                    }
                });
            });

            document.getElementById('osc2Level').addEventListener('input', (e) => {
                synthParams.osc2Level = parseFloat(e.target.value);
                if (osc2LevelValue) {
                    osc2LevelValue.textContent = Math.round(synthParams.osc2Level * 100) + '%';
                }
                if (!audioContext) {
                    return;
                }
                const time = audioContext.currentTime;
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.osc2Gain) {
                        voice.osc2Gain.gain.setValueAtTime(synthParams.osc2Level, time);
                    }
                });
            });

            document.getElementById('lfoTarget').addEventListener('change', (e) => {
                synthParams.lfoTarget = e.target.value;
                rebuildAllVoiceLFOs();
            });

            document.getElementById('lfoWaveform').addEventListener('change', (e) => {
                synthParams.lfoWaveform = e.target.value;
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.lfoOsc) {
                        voice.lfoOsc.type = synthParams.lfoWaveform;
                    }
                });
            });

            document.getElementById('lfoRate').addEventListener('input', (e) => {
                synthParams.lfoRate = parseFloat(e.target.value);
                if (lfoRateValue) {
                    lfoRateValue.textContent = synthParams.lfoRate.toFixed(1) + 'Hz';
                }
                if (!audioContext) {
                    return;
                }
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.lfoOsc) {
                        voice.lfoOsc.frequency.setValueAtTime(synthParams.lfoRate, audioContext.currentTime);
                    }
                });
            });

            document.getElementById('lfoDepth').addEventListener('input', (e) => {
                synthParams.lfoDepth = parseFloat(e.target.value);
                if (lfoDepthValue) {
                    lfoDepthValue.textContent = synthParams.lfoDepth.toFixed(0);
                }
                if (!audioContext) {
                    return;
                }
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.lfoGain) {
                        const targetGain = synthParams.lfoTarget === 'filter'
                            ? synthParams.lfoDepth * 20
                            : synthParams.lfoDepth;
                        voice.lfoGain.gain.setValueAtTime(targetGain, audioContext.currentTime);
                    }
                });
            });

            if (envAttackSlider) {
                envAttackSlider.addEventListener('input', (e) => {
                    synthParams.envAttack = parseFloat(e.target.value);
                    if (envAttackValue) {
                        envAttackValue.textContent = synthParams.envAttack.toFixed(2) + 's';
                    }
                });
            }

            if (envDecaySlider) {
                envDecaySlider.addEventListener('input', (e) => {
                    synthParams.envDecay = parseFloat(e.target.value);
                    if (envDecayValue) {
                        envDecayValue.textContent = synthParams.envDecay.toFixed(2) + 's';
                    }
                });
            }

            if (envSustainSlider) {
                envSustainSlider.addEventListener('input', (e) => {
                    synthParams.envSustain = parseFloat(e.target.value) / 100;
                    if (envSustainValue) {
                        envSustainValue.textContent = Math.round(synthParams.envSustain * 100) + '%';
                    }
                });
            }

            if (envReleaseSlider) {
                envReleaseSlider.addEventListener('input', (e) => {
                    synthParams.envRelease = parseFloat(e.target.value);
                    if (envReleaseValue) {
                        envReleaseValue.textContent = synthParams.envRelease.toFixed(2) + 's';
                    }
                });
            }

            if (transientAmountSlider) {
                transientAmountSlider.addEventListener('input', (e) => {
                    synthParams.transientAmount = parseFloat(e.target.value);
                    if (transientAmountValue) {
                        transientAmountValue.textContent = `+${synthParams.transientAmount.toFixed(1)} dB`;
                    }
                });
            }

            if (transientLengthSlider) {
                transientLengthSlider.addEventListener('input', (e) => {
                    const lengthMs = parseInt(e.target.value, 10);
                    synthParams.transientLength = lengthMs / 1000;
                    if (transientLengthValue) {
                        transientLengthValue.textContent = lengthMs + 'ms';
                    }
                });
            }

            if (driveAmountSlider) {
                driveAmountSlider.addEventListener('input', (e) => {
                    synthParams.driveAmount = parseFloat(e.target.value);
                    if (driveAmountValue) {
                        driveAmountValue.textContent = `+${synthParams.driveAmount.toFixed(1)} dB`;
                    }
                    updateDriveModuleSettings();
                });
            }

            if (foldAmountSlider) {
                foldAmountSlider.addEventListener('input', (e) => {
                    synthParams.foldAmount = parseFloat(e.target.value);
                    if (foldAmountValue) {
                        foldAmountValue.textContent = Math.round(synthParams.foldAmount) + '%';
                    }
                    updateDriveModuleSettings();
                });
            }

            if (toneTiltSlider) {
                toneTiltSlider.addEventListener('input', (e) => {
                    synthParams.toneTilt = parseFloat(e.target.value);
                    if (toneTiltValue) {
                        toneTiltValue.textContent = synthParams.toneTilt.toFixed(1) + ' dB';
                    }
                    updateDriveModuleSettings();
                });
            }

            document.getElementById('filterType').addEventListener('change', (e) => {
                synthParams.filterType = e.target.value;
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.filter) {
                        voice.filter.type = synthParams.filterType;
                    }
                });
            });

            document.getElementById('filterCutoff').addEventListener('input', (e) => {
                synthParams.filterCutoff = parseFloat(e.target.value);
                document.getElementById('cutoffValue').textContent = Math.round(synthParams.filterCutoff) + 'Hz';
                if (!audioContext) {
                    return;
                }
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.filter) {
                        voice.filter.frequency.setValueAtTime(synthParams.filterCutoff, audioContext.currentTime);
                    }
                });
            });

            document.getElementById('filterResonance').addEventListener('input', (e) => {
                synthParams.filterResonance = parseFloat(e.target.value);
                document.getElementById('resonanceValue').textContent = synthParams.filterResonance.toFixed(1);
                if (!audioContext) {
                    return;
                }
                Object.values(activeOscillators).forEach(voice => {
                    if (voice.filter) {
                        voice.filter.Q.setValueAtTime(synthParams.filterResonance, audioContext.currentTime);
                    }
                });
            });

            document.getElementById('reverbRoomSize').addEventListener('input', (e) => {
                synthParams.reverbRoomSize = parseFloat(e.target.value);
                document.getElementById('roomSizeValue').textContent = synthParams.reverbRoomSize.toFixed(1) + 's';
                updateReverb();
            });

            document.getElementById('reverbDecay').addEventListener('input', (e) => {
                synthParams.reverbDecay = parseFloat(e.target.value);
                document.getElementById('decayValue').textContent = synthParams.reverbDecay.toFixed(1) + 's';
                updateReverb();
            });

            document.getElementById('reverbMix').addEventListener('input', (e) => {
                synthParams.reverbMix = parseFloat(e.target.value);
                document.getElementById('mixValue').textContent = synthParams.reverbMix.toFixed(0) + '%';
                updateReverbMix();
            });

            updateDriveModuleSettings();
        }

        async function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            
            if (key === 'z') {
                changeOctave(-1);
                return;
            }
            if (key === 'x') {
                changeOctave(1);
                return;
            }

            if (keyMap[key] && !e.repeat) {
                await playNote(keyMap[key], key);
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (keyMap[key]) {
                stopNote(key);
            }
        }

        function changeOctave(direction) {
            currentOctave = Math.max(1, Math.min(7, currentOctave + direction));
            document.getElementById('octaveDisplay').textContent = `Octave: ${currentOctave}`;
        }

        init();
    </script>
</body>
</html>
